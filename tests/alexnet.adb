pragma Ada_95;
pragma Profile (Ravenscar);
with Float_Arrays_Operators; use Float_Arrays_Operators;
with Utils; use Utils;
with Ada.Command_Line; use Ada.Command_Line;
package body AlexNet is
    variable_12: Real_Matrix (1..4096, 1..4096);
    variable_13: Real_Matrix (1..1, 1..4096);
    variable_14: Real_Matrix (1..1000, 1..4096);
    variable_15: Real_Matrix (1..1, 1..1000);
    variable_10: Real_Matrix (1..4096, 1..9216);
    variable_9: Real_Matrix (1..1, 1..256);
    variable_8: Real_Tensor_4D (1..256, 1..192, 1..3, 1..3);
    variable_6: Real_Tensor_4D (1..384, 1..192, 1..3, 1..3);
    variable_5: Real_Matrix (1..1, 1..384);
    variable_4: Real_Tensor_4D (1..384, 1..256, 1..3, 1..3);
    variable_2: Real_Tensor_4D (1..256, 1..48, 1..5, 1..5);
    variable_0: Real_Tensor_4D (1..96, 1..3, 1..11, 1..11);
    variable_1: Real_Matrix (1..1, 1..96);
    variable_3: Real_Matrix (1..1, 1..256);
    variable_7: Real_Matrix (1..1, 1..384);
    variable_11: Real_Matrix (1..1, 1..4096);
        conv_0: Real_Tensor_4D (1..1, 1..96, 1..55, 1..55);
        relu_0: Real_Tensor_4D (1..1, 1..96, 1..55, 1..55);
        sqr1: Real_Tensor_4D (1..1, 1..96, 1..55, 1..55);
        box1: Real_Tensor_4D (1..1, 1..96, 1..55, 1..55);
        mul1: Real_Tensor_4D (1..1, 1..96, 1..55, 1..55);
        add1: Real_Tensor_4D (1..1, 1..96, 1..55, 1..55);
        pow1: Real_Tensor_4D (1..1, 1..96, 1..55, 1..55);
        local_response_normalization_0: Real_Tensor_4D (1..1, 1..96, 1..55, 1..55);
        max_pool_0: Real_Tensor_4D (1..1, 1..96, 1..27, 1..27);
        conv_1: Real_Tensor_4D (1..1, 1..256, 1..27, 1..27);
        relu_1: Real_Tensor_4D (1..1, 1..256, 1..27, 1..27);
        sqr2: Real_Tensor_4D (1..1, 1..256, 1..27, 1..27);
        box2: Real_Tensor_4D (1..1, 1..256, 1..27, 1..27);
        mul2: Real_Tensor_4D (1..1, 1..256, 1..27, 1..27);
        add2: Real_Tensor_4D (1..1, 1..256, 1..27, 1..27);
        pow2: Real_Tensor_4D (1..1, 1..256, 1..27, 1..27);
        local_response_normalization_1: Real_Tensor_4D (1..1, 1..256, 1..27, 1..27);
        max_pool_1: Real_Tensor_4D (1..1, 1..256, 1..13, 1..13);
        conv_2: Real_Tensor_4D (1..1, 1..384, 1..13, 1..13);
        relu_2: Real_Tensor_4D (1..1, 1..384, 1..13, 1..13);
        conv_3: Real_Tensor_4D (1..1, 1..384, 1..13, 1..13);
        relu_3: Real_Tensor_4D (1..1, 1..384, 1..13, 1..13);
        conv_4: Real_Tensor_4D (1..1, 1..256, 1..13, 1..13);
        relu_4: Real_Tensor_4D (1..1, 1..256, 1..13, 1..13);
        max_pool_2: Real_Tensor_4D (1..1, 1..256, 1..6, 1..6);
        reshape_0: Real_Matrix (1..1, 1..9216);
        linear_0: Real_Matrix (1..1, 1..4096);
        relu_5: Real_Matrix (1..1, 1..4096);
        linear_1: Real_Matrix (1..1, 1..4096);
        relu_6: Real_Matrix (1..1, 1..4096);
        linear_2: Real_Matrix (1..1, 1..1000);
    procedure Forward (data: Real_Tensor_4D; prob: out Real_Matrix) is
    begin
        conv (input => data, filter => variable_0, bias => variable_1, border => Border_Mode_constant, padding => ((0, 0), (0, 0)), stride => (4, 4), dilation => (1, 1), groups => 1, output => conv_0);
        relu (x => conv_0, y => relu_0);
        sqr (x => relu_0, y => sqr1);
        box (input => sqr1, size => (1, 5, 1, 1), border => Border_Mode_constant, padding => Padding_Auto, stride => Default_Stride, dilation => Default_Dilation, normalize => true, output => box1);
        mul (x => box1, y => 0.0001, z => mul1);
        add (x => mul1, y => 1.0, z => add1);
        pow (x => add1, y => 0.75, z => pow1);
        div (x => relu_0, y => pow1, z => local_response_normalization_0);
        max_pool (input => local_response_normalization_0, size => (1, 1, 3, 3), border => Border_Mode_ignore, padding => ((0, 0), (0, 0), (0, 0), (0, 0)), stride => (1, 1, 2, 2), dilation => Default_Dilation, output => max_pool_0);
        conv (input => max_pool_0, filter => variable_2, bias => variable_3, border => Border_Mode_constant, padding => ((2, 2), (2, 2)), stride => (1, 1), dilation => (1, 1), groups => 2, output => conv_1);
        relu (x => conv_1, y => relu_1);
        sqr (x => relu_1, y => sqr2);
        box (input => sqr2, size => (1, 5, 1, 1), border => Border_Mode_constant, padding => Padding_Auto, stride => Default_Stride, dilation => Default_Dilation, normalize => true, output => box2);
        mul (x => box2, y => 0.0001, z => mul2);
        add (x => mul2, y => 1.0, z => add2);
        pow (x => add2, y => 0.75, z => pow2);
        div (x => relu_1, y => pow2, z => local_response_normalization_1);
        max_pool (input => local_response_normalization_1, size => (1, 1, 3, 3), border => Border_Mode_ignore, padding => ((0, 0), (0, 0), (0, 0), (0, 0)), stride => (1, 1, 2, 2), dilation => Default_Dilation, output => max_pool_1);
        conv (input => max_pool_1, filter => variable_4, bias => variable_5, border => Border_Mode_constant, padding => ((1, 1), (1, 1)), stride => (1, 1), dilation => (1, 1), groups => 1, output => conv_2);
        relu (x => conv_2, y => relu_2);
        conv (input => relu_2, filter => variable_6, bias => variable_7, border => Border_Mode_constant, padding => ((1, 1), (1, 1)), stride => (1, 1), dilation => (1, 1), groups => 2, output => conv_3);
        relu (x => conv_3, y => relu_3);
        conv (input => relu_3, filter => variable_8, bias => variable_9, border => Border_Mode_constant, padding => ((1, 1), (1, 1)), stride => (1, 1), dilation => (1, 1), groups => 2, output => conv_4);
        relu (x => conv_4, y => relu_4);
        max_pool (input => relu_4, size => (1, 1, 3, 3), border => Border_Mode_ignore, padding => ((0, 0), (0, 0), (0, 0), (0, 0)), stride => (1, 1, 2, 2), dilation => Default_Dilation, output => max_pool_2);
        reshape (input => max_pool_2, output => reshape_0);
        linear (input => reshape_0, filter => variable_10, bias => variable_11, output => linear_0);
        relu (x => linear_0, y => relu_5);
        linear (input => relu_5, filter => variable_12, bias => variable_13, output => linear_1);
        relu (x => linear_1, y => relu_6);
        linear (input => relu_6, filter => variable_14, bias => variable_15, output => linear_2);
        softmax (x => linear_2, axes => (1 => 2), y => prob);
    end Forward;
    procedure Variable (Var_Name: String; Tensor: out Real_Matrix) is
    begin
        Load_TFF_Data(Argument(2) & Var_Name & ".dat", Tensor);
    end Variable;
    pragma Inline (Variable);
    procedure Variable (Var_Name: String; Tensor: out Real_Tensor_4D) is
    begin
        Load_TFF_Data(Argument(2) & Var_Name & ".dat", Tensor);
    end Variable;
    pragma Inline (Variable);
    --  procedure Trace (Path: String) is
    --      use Utils;
    --  begin
    --      Write_TFF_Data(conv_0, Path & "conv_0.dat");
    --      Write_TFF_Data(relu_0, Path & "relu_0.dat");
    --      --  Write_TFF_Data(sqr1, Path & "sqr1.dat");
    --      Write_TFF_Data(box1, Path & "box1.dat");
    --      --  Utils.Write_TFF_Data(mul1, Path & "mul1.dat");
    --      --  Utils.Write_TFF_Data(add1, Path & "add1.dat");
    --      --  Utils.Write_TFF_Data(pow1, Path & "pow1.dat");
    --      Write_TFF_Data(local_response_normalization_0, Path & "local_response_normalization_0.dat");
    --      Write_TFF_Data(max_pool_0, Path & "max_pool_0.dat");
    --      Write_TFF_Data(conv_1, Path & "conv_1.dat");
    --      Write_TFF_Data(relu_1, Path & "relu_1.dat");
    --      --  Utils.Write_TFF_Data(sqr2, Path & "sqr2.dat");
    --      Write_TFF_Data(box2, Path & "box2.dat");
    --      --  Utils.Write_TFF_Data(mul2, Path & "mul2.dat");
    --      --  Utils.Write_TFF_Data(add2, Path & "add2.dat");
    --      --  Utils.Write_TFF_Data(pow2, Path & "pow2.dat");
    --      Write_TFF_Data(local_response_normalization_1, Path & "local_response_normalization_1.dat");
    --      Write_TFF_Data(max_pool_1, Path & "max_pool_1.dat");
    --      Write_TFF_Data(conv_2, Path & "conv_2.dat");
    --      Write_TFF_Data(relu_2, Path & "relu_2.dat");
    --      Write_TFF_Data(conv_3, Path & "conv_3.dat");
    --      Write_TFF_Data(relu_3, Path & "relu_3.dat");
    --      Write_TFF_Data(conv_4, Path & "conv_4.dat");
    --      Write_TFF_Data(relu_4, Path & "relu_4.dat");
    --      Write_TFF_Data(max_pool_2, Path & "max_pool_2.dat");
    --      --  Write_TFF_Data(reshape_0, Path & "reshape_0.dat");
    --      Write_TFF_Data(linear_0, Path & "linear_0.dat");
    --      Write_TFF_Data(relu_5, Path & "relu_5.dat");
    --      Write_TFF_Data(linear_1, Path & "linear_1.dat");
    --      Write_TFF_Data(relu_6, Path & "relu_6.dat");
    --      Write_TFF_Data(linear_2, Path & "linear_2.dat");
    --  end Trace;
begin
    variable ("fc7_blob1", variable_12);
    variable ("fc7_blob2", variable_13);
    variable ("fc8_blob1", variable_14);
    variable ("fc8_blob2", variable_15);
    variable ("fc6_blob1", variable_10);
    variable ("conv5_blob2", variable_9);
    variable ("conv5_blob1", variable_8);
    variable ("conv4_blob1", variable_6);
    variable ("conv3_blob2", variable_5);
    variable ("conv3_blob1", variable_4);
    variable ("conv2_blob1", variable_2);
    variable ("conv1_blob1", variable_0);
    variable ("conv1_blob2", variable_1);
    variable ("conv2_blob2", variable_3);
    variable ("conv4_blob2", variable_7);
    variable ("fc6_blob2", variable_11);
end AlexNet;
